# 01 코틀린 기초
* 객체 지향을 원칙으로 하며, 자바와 100% 연계되는 문법을 사용하고 있다.
* 코드가 매우 간결하여 쉽게 배울 수 있으며, 안드로이드 앱을 만들 때도 기능상의 제한이 없다.
* 함수 선언 방법 또한 자바와 동일하다.

## 변수
```kotlin
fun main(){
    val a = 12 // 타입을 명시 하지 않아도 됨
    va1 a: Int = 12    // 타입명시    
}
```
타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
여기서 초기화 식은 12로 Int 타입이다. 따라서 변수도 Int 타입이 된다.
```kotlin
fun main(){
    val a : Int
    a = 12    
}
```
초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
* val(value에서 따옴) : 변경 불가능한 참조를 저장하는 변수. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. -> JAVA의 final
* var(variable에서 따옴) : 변경 가능한 참조. 이런 변수의 값은 바뀔 수 있다. -> JAVA의 일반 변수
* 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경을 권장
```kotlin
fun main(){
    val languages = arrayListOf("JAVA") // 불변 참조를 선언
    languages.add("Kotlin") // 참조가 가리키는 객체 내부를 변겅
}
```
val 참조 자체는 불변일지 몰라도, 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.
```kotlin
fun main(){
    var answer = 11
    answer = "no answer"    // <- 컨파일 오류 발생 "Erro: type mismatch"
}
```
var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.
위와 같이 문자열 리터럴(string literal)에서 컴파일 오류가 발생. 그 이유는 타입이 컴파일러가 기대하는 타입과 다르기 때문이다.
컴파일러는 변수 선언 시점의 초기화 식으로부터 변수 타입을 추론하며, 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.
어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면, 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 **형 변환** 해야한다.

## 형변환
```kotlin
fun main(){
    var a: Int = 123
    var b: String = a.toString()
    print(b)
}
```
코틀린에서는 to변수()를 통해 형변환이 가능하다. 
> 코틀린은 암시적 형변환을 지원하지 않음

## 배열
* 코틀린의 배열은타입 파라미터르 받는 클래스
```kotlin
fun main(){
	//int형으로 1 2 3 4 배열 생성
    var intArr:Array<Int> = arrayOf(1, 2, 3, 4)
    //type 생략 가능
    var intArr2 = arrayOfNulls<Int>(5)
    //Any는 데이터 타입의 최상위(어느 데이터든 다 들어갈 수 있음)
    var anyArr : Array<Any> = arrayOf(1, "awd", 3.2, 4)	
    print(intArr[0])
    print(intArr2[1])
    print(anyArr[1])
}

출력
1
null
awd
```
### 코틀린에서 배열을 만드는 방법
* arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다.
* arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 값은 배열을 만들 수 있다. (원소 타입이 널이 될 수 있는 타입인 경우에만 이 함수를 쓸 수 있다.)
* Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해준다. arrayOf를 쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경우 이 생성자를 사용한다.


