# 01 코틀린
* 객체 지향을 원칙으로 하며, 자바와 100% 연계되는 문법을 사용하고 있다.
* 코드가 매우 간결하여 쉽게 배울 수 있으며, 안드로이드 앱을 만들 때도 기능상의 제한이 없다.
* 함수 선언 방법 또한 자바와 동일하다.

## 변수
```kotlin
fun main(){
    val a = 12 // 타입을 명시 하지 않아도 됨
    va1 a: Int = 12    // 타입명시    
}
```
타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
여기서 초기화 식은 12로 Int 타입이다. 따라서 변수도 Int 타입이 된다.
```kotlin
fun main(){
    val a : Int
    a = 12    
}
```
초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
* val(value에서 따옴) : 변경 불가능한 참조를 저장하는 변수. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. -> JAVA의 final
* var(variable에서 따옴) : 변경 가능한 참조. 이런 변수의 값은 바뀔 수 있다. -> JAVA의 일반 변수
* 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경을 권장
```kotlin
fun main(){
    val languages = arrayListOf("JAVA") // 불변 참조를 선언
    languages.add("Kotlin") // 참조가 가리키는 객체 내부를 변겅
}
```
val 참조 자체는 불변일지 몰라도, 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.
```kotlin
fun main(){
    var answer = 11
    answer = "no answer"    // <- 컨파일 오류 발생 "Erro: type mismatch"
}
```
var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.
위와 같이 문자열 리터럴(string literal)에서 컴파일 오류가 발생. 그 이유는 타입이 컴파일러가 기대하는 타입과 다르기 때문이다.
컴파일러는 변수 선언 시점의 초기화 식으로부터 변수 타입을 추론하며, 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.
어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면, 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 **형 변환** 해야한다.

## 형변환
```kotlin
fun main(){
    var a: Int = 123
    var b: String = a.toString()
    print(b)
}
```
코틀린에서는 to변수()를 통해 형변환이 가능하다. 
> 코틀린은 암시적 형변환을 지원하지 않음

## 배열
* 코틀린의 배열은타입 파라미터르 받는 클래스
```kotlin
fun main(){
	//int형으로 1 2 3 4 배열 생성
    var intArr:Array<Int> = arrayOf(1, 2, 3, 4)
    //type 생략 가능
    var intArr2 = arrayOfNulls<Int>(5)
    //Any는 데이터 타입의 최상위(어느 데이터든 다 들어갈 수 있음)
    var anyArr : Array<Any> = arrayOf(1, "awd", 3.2, 4)	
    print(intArr[0])
    print(intArr2[1])
    print(anyArr[1])
}

출력
1
null
awd
```
### 코틀린에서 배열을 만드는 방법
* arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다.
* arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 값은 배열을 만들 수 있다. (원소 타입이 널이 될 수 있는 타입인 경우에만 이 함수를 쓸 수 있다.)
* Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해준다. arrayOf를 쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경우 이 생성자를 사용한다.

## 추상 클래스와 인터페이스
* **추상클래스**는 대략적인 설계의 명세와 공통의 기능을 구현한 클래스이다.
즉, **구체적이지 않은 것**이다. 추상 클래스를 상속하는 하위 클래스는 추상 클래스의 내용을 더 구체화 해야 한다.

* 인터페이스 역시 대략적인 설계 명세를 구현하고 인터페이스를 상속하는 하위 클래스에서 이를 **구체화** 하는 것은 동일하다. 하지만 **인터페이스에서는 프로퍼티의 상태 정보를 저장할 수 없다.** 다시 말하면 인터페이스에서는 프로퍼티의 초기화가 불가능하다.

#### 추상 클래스
추상 클래스는 위에서 말한 것처럼 **구체화되지 않은 클래스**이기 떄문에 일반적인 객채를 생성하는 방법으로 인스턴스화될 수 없다. 추상 클래스를 정의하기 위해선 **abstract** 라는 키워드를 사용해야 한다. 또한 **클래스 내에서의 프로퍼티나 메소드도 abstract로 선언**할수 있다. 하지만 이를 사용하기 위해서는 해당 클래스가 추상 클래스가 되어야한다.
```kotlin
// abstract로 정의한 추상 클래스이다. 주생성자를 사용했다.
abstract class Vehicle(val name : String, val color : String, val weight : Double) {
	// abstract로 정의한 추상 프로퍼티이므로 하위 클래스에서 반드시 재정의해야한다.
	abstract var maxSpeed : Double 
	
	// 초기값을 갖는 일반 프로퍼티 (인터페이스에서는 불가능)	
	var year = "2021"

	// abstract로 정의한 추상 메소드이므로 하위 클래스에서 반드시 재정의해야한다.
	abstract fun start()
	abstract fun stop()
	
	fun displaySpecs() {
		println("Name : $name, Color : $color, Weight : $weight, Year : $year, MaxSpeed : $maxSpeed")
	}
}
```
Vehicle 클래스 는 **abstract로 정의한 추상 클래스**이므로 **기본적인 설계만 정의**하고 있다. abstract 를 사용한 **maxSpeed, start(), stop()은 반드시 하위 클래스에서 재정의 해줘야한다.**
추상 클래스에서는 open 키워드를 사용하지 않아도 된다. 추상 프로퍼티나 추상메소드도 마찬가지다.
* Vehicle 클래스를 상속해보기
```kotlin
class Car(name : String, color : String, weight : Double, override var maxSpeed : Double) : Vehicle(name, color, weight) {
	override fun start() {
		// 재정의
		println("Car start")
	}

	override fun stop() {
		// 재정의
		println("Car Stop")
	}
}

class Bicycle(name : String, color : String, weight : Double, override var maxSpeed : Double) : Vehicle(name, color, weight) {
	override fun start() {
		// 재정의
		println("Bicycle start")
	}

	override fun stop() {
		// 재정의
		println("Bicycle Stop")
	}
}

fun main() {
	val car = Car("Matiz", "Yellow", 1000, 150)
	val bicycle = Bicycle("Bike", "Red", 150, 100)
	
	// 새로운 값 할당
	car.year = "2020"
	
	car.displaySpec()
	car.start()
	bicycle.displaySpec()
	bicycle.start()
}
```
displaySpec 은 추상 클래스가 갖고 있던 일반 메소드이다. start와 stop은 추상클래스를 상속받은 자식 클래스에서 오버라이딩한 메소드이다. **추상클래스에서 abstract로 정의한 프로퍼티나 메소드들은 자식 클래스에서 반드시 재정의되어야한다.**

> [추상클래스를 이용한 예제 : 사칙연산 계산기](https://github.com/KyungHwa0/calculator.git)

#### 인터페이스




